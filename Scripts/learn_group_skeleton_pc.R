if(!exists("conditional_independence_group_test", mode="function")) source("conditional_independence_group_test.R")

#'@title learn_skeleton_group_pc
#'@description Learn a skeleton DAG by using PC algorithm along with our proposed
#' conditional independence test, delta-d-separation
#'@param dag The variable DAG learnt by using PC algorithm.
#'@param groups a vector of groups generated by using Module Network
#'@param ratio the threshold for delta-d-separation.
#'@param m.max maximal size of conditioning set
#'@param fixedGaps the adjacency matrix of the graph from which the algorithm 
#'should start (logical); gaps fixed here are not changed.
#'@param fixedEdges Edges marked here are not changed (logical)
#'@param verbose Whether or not print process logs
#'@return a skeleton of group DAG.
learn_skeleton_group_pc <- function(dag,
                                    groups,
                                    ratio,
                                    labels,
                                    p,
                                    m.max = Inf,
                                    fixedGaps = NULL,
                                    fixedEdges = NULL,
                                    numCores = 1,
                                    verbose = FALSE)
{
  # Set cores
  nCores <- max(detectCores() - 1, 1)
  if (numCores != -1 && numCores < nCores) {
    nCores <- numCores
  } 
  cl <- makeCluster(nCores)
  registerDoParallel(cl)
  if (verbose)
    cat("Register nCores =", nCores, "\n")
  
  # pcalg: skeleton
  cl <- match.call()
  if (!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)
  if (missing(labels)) {
    if (missing(p))
      stop("need to specify 'labels' or 'p'")
    labels <- as.character(seq_len(p))
  } else {
    ## use labels ==> p  from it
    stopifnot(is.character(labels))
    if (missing(p))
      p <- length(labels)
    else if (p != length(labels))
      stop("'p' is not needed when 'labels' is specified, and must match length(labels)")
    ## Don't want message, in case this is called e.g. from fciPlus():
    ## else
    ##   message("No need to specify 'p', when 'labels' is given")
  }
  seq_p <- seq_len(p)
  #method <- match.arg(method)
  ## C++ version still has problems under Windows; will have to check why
  ##  if (method == "stable.fast" && .Platform$OS.type == "windows") {
  ##    method <- "stable"
  ##    warning("Method 'stable.fast' is not available under Windows; using 'stable' instead.")
  ##  }
  
  ## G := !fixedGaps, i.e. G[i,j] is true  iff  i--j  will be investigated
  if (is.null(fixedGaps)) {
    G <- matrix(TRUE, nrow = p, ncol = p)
  }
  else if (!identical(dim(fixedGaps), c(p, p)))
    stop("Dimensions of the dataset and fixedGaps do not agree.")
  else if (!identical(fixedGaps, t(fixedGaps)))
    stop("fixedGaps must be symmetric")
  else
    G <- !fixedGaps
  
  diag(G) <- FALSE
  
  if (any(is.null(fixedEdges))) {
    ## MM: could be sparse
    fixedEdges <- matrix(rep(FALSE, p * p), nrow = p, ncol = p)
  }
  else if (!identical(dim(fixedEdges), c(p, p)))
    stop("Dimensions of the dataset and fixedEdges do not agree.")
  else if (!identical(fixedEdges, t(fixedEdges)))
    stop("fixedEdges must be symmetric")
  
  
  ## Original R version
  sepset <- lapply(seq_p, function(.) vector("list", p))# a list of lists [p x p]
  done <- FALSE
  ord <- 0L
  n.edgetests <- numeric(1)# final length = max { ord}
  while (!done && any(G) && ord <= m.max) {
    n.edgetests[ord1 <- ord + 1L] <- 0
    done <- TRUE
    ind <- which(G, arr.ind = TRUE)
    ## For comparison with C++ sort according to first row
    ind <- ind[order(ind[, 1]), ]
    remEdges <- nrow(ind)
    if (verbose)
      cat("Order=", ord, "; remaining edges:", remEdges, "\n", sep = "")
    # if(method == "stable") {
    ## Order-independent version: Compute the adjacency sets for any vertex
    ## Then don't update when edges are deleted
    #  G.l <- split(G, gl(p,p))
    # }
    for (i in 1:remEdges) {
      x <- ind[i, 1]
      y <- ind[i, 2]
      if (G[y, x] && !fixedEdges[y, x]) {
        nbrsBool <-  G[, x]
        nbrsBool[y] <- FALSE
        nbrs <- seq_p[nbrsBool]
        length_nbrs <- length(nbrs)
        if (length_nbrs >= ord) {
          if (length_nbrs > ord)
            done <- FALSE
          S <- seq_len(ord)
          repeat {
            ## condition w.r.to all  nbrs[S] of size 'ord'
            n.edgetests[ord1] <- n.edgetests[ord1] + 1
            group_CI <- conditional_independence_group_test(dag, groups, x, y, nbrs[S], ratio)
            if (verbose)
              cat("x=", x, " y=", y, " S=", nbrs[S], ": pval =", group_CI, "\n")
            if (group_CI) {
              # independent
              G[x, y] <- G[y, x] <- FALSE
              sepset[[x]][[y]] <- nbrs[S]
              break
            }
            else {
              nextSet <- getNextSet(length_nbrs, ord, S)
              if (nextSet$wasLast)
                break
              S <- nextSet$nextSet
            }
          } ## repeat
        }
      }
    }# for( i )
    ord <- ord + 1L
  } ## while()
  
  
  ## transform matrix to graph object :
  Gobject <-
    if (sum(G) == 0) {
      new("graphNEL", nodes = labels)
    } else {
      colnames(G) <- rownames(G) <- labels
      as(G, "graphNEL")
    }
  
  ## final object
  new(
    "pcAlgo",
    graph = Gobject,
    call = cl,
    n = integer(0),
    max.ord = as.integer(ord - 1),
    n.edgetests = n.edgetests,
    sepset = sepset,
    zMin = matrix(NA, 1, 1)
  )
}